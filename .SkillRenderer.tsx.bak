import React, { useEffect, useRef, useState } from 'react';
import { createRoot } from 'react-dom/client';
import SkillItem from './SkillItem';
import MermaidLazyChart from '../mermaid/MermaidLazyChart';
import { getLogger } from '../../utils/Tools';

/**
 * ç®€å•çš„å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°ï¼Œç”¨äºç”Ÿæˆç¨³å®šçš„ID
 */
const hashString = (str: string): string => {
    let hash = 0;
    if (str.length === 0) return hash.toString();
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return Math.abs(hash).toString(36);
};
const logMermaid = getLogger(`Mermaid`);

/**
 * å®‰å…¨åœ°ä½¿ç”¨ä¸»é¢˜hook
 * æ”¯æŒæœåŠ¡å™¨ç«¯æ¸²æŸ“å’Œå®¢æˆ·ç«¯æ¸²æŸ“
 * å½“ç»„ä»¶åœ¨ç‹¬ç«‹çš„Reactæ ¹ä¸­æ¸²æŸ“æ—¶ï¼Œç›´æ¥ä»DOMè·å–ä¸»é¢˜çŠ¶æ€
 */
export const useSafeTheme = () => {
    const [isDark, setIsDark] = useState(false);

    useEffect(() => {
        // åœ¨æœåŠ¡å™¨ç«¯æ¸²æŸ“æ—¶ï¼Œè¿”å›é»˜è®¤å€¼
        if (typeof window === 'undefined') {
            return;
        }

        // ç›´æ¥ä»DOMè·å–ä¸»é¢˜çŠ¶æ€ï¼Œä¸ä¾èµ–React Context
        const getThemeFromDOM = () => {
            // æ–¹æ³•1: æ£€æŸ¥bodyçš„data-themeå±æ€§
            const bodyTheme = document.body.getAttribute('data-theme');
            if (bodyTheme) {
                return bodyTheme === 'dark';
            }

            // æ–¹æ³•2: æ£€æŸ¥htmlçš„data-themeå±æ€§
            const htmlTheme = document.documentElement.getAttribute('data-theme');
            if (htmlTheme) {
                return htmlTheme === 'dark';
            }

            // æ–¹æ³•3: æ£€æŸ¥htmlçš„class
            const htmlClasses = document.documentElement.className;
            if (htmlClasses.includes('dark')) {
                return true;
            }
            if (htmlClasses.includes('light')) {
                return false;
            }

            // æ–¹æ³•4: æ£€æŸ¥localStorage
            try {
                const storedTheme = localStorage.getItem('theme');
                if (storedTheme) {
                    return storedTheme === 'dark';
                }
            } catch (e) {
                // localStorageå¯èƒ½ä¸å¯ç”¨
            }

            // æ–¹æ³•5: æ£€æŸ¥ç³»ç»Ÿåå¥½
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                return true;
            }

            // é»˜è®¤è¿”å›falseï¼ˆæµ…è‰²ä¸»é¢˜ï¼‰
            return false;
        };

        // åˆå§‹è®¾ç½®
        setIsDark(getThemeFromDOM());

        // ç›‘å¬ä¸»é¢˜å˜åŒ–
        const observer = new MutationObserver(() => {
            setIsDark(getThemeFromDOM());
        });

        observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class', 'data-theme']
        });

        observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['class', 'data-theme']
        });

        // ç›‘å¬localStorageå˜åŒ–
        const handleStorageChange = (e: StorageEvent) => {
            if (e.key === 'theme') {
                setIsDark(getThemeFromDOM());
            }
        };

        window.addEventListener('storage', handleStorageChange);

        // æ¸…ç†å‡½æ•°
        return () => {
            observer.disconnect();
            window.removeEventListener('storage', handleStorageChange);
        };
    }, []);

    return { isDark };
};

/**
 * SkillRenderer ç»„ä»¶
 * ç”¨äºåœ¨å®¢æˆ·ç«¯å°†å ä½ç¬¦æ›¿æ¢ä¸ºçœŸæ­£çš„ React ç»„ä»¶
 * - æŠ€èƒ½å ä½ç¬¦ -> SkillItem ç»„ä»¶
 * - Mermaidå ä½ç¬¦ -> MermaidChart ç»„ä»¶
 * è¿™æ ·å¯ä»¥ç¡®ä¿ç»„ä»¶åœ¨æ­£ç¡®çš„ React ä¸Šä¸‹æ–‡ä¸­æ¸²æŸ“ï¼ŒåŒ…æ‹¬ ThemeProvider
 */
interface SkillRendererProps {
    children: React.ReactNode;
}

const SkillRenderer: React.FC<SkillRendererProps> = ({ children }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const { isDark } = useSafeTheme(); // ç›‘å¬ä¸»é¢˜å˜åŒ–
    const rootsRef = useRef<Map<string, any>>(new Map()); // å­˜å‚¨æ‰€æœ‰åˆ›å»ºçš„æ ¹

    useEffect(() => {
        if (!containerRef.current) return;

        // æ¸…ç†æ‰€æœ‰å¤±æ•ˆçš„æ ¹èŠ‚ç‚¹ - å¼‚æ­¥å¤„ç†é¿å…ç«æ€æ¡ä»¶
        const cleanupInvalidRoots = () => {
            const keysToDelete: string[] = [];
            const rootsToUnmount: any[] = [];

            rootsRef.current.forEach((root, id) => {
                const container = document.getElementById(id);
                if (!container || !document.body.contains(container)) {
                    rootsToUnmount.push(root);
                    keysToDelete.push(id);
                }
            });

            // ç«‹å³ä»Mapä¸­åˆ é™¤å¼•ç”¨ï¼Œé¿å…é‡å¤å¤„ç†
            keysToDelete.forEach(key => rootsRef.current.delete(key));

            // å¼‚æ­¥å¸è½½æ ¹èŠ‚ç‚¹ï¼Œé¿å…åœ¨æ¸²æŸ“å‘¨æœŸä¸­åŒæ­¥å¸è½½
            if (rootsToUnmount.length > 0) {
                setTimeout(() => {
                    rootsToUnmount.forEach(root => {
                        try {
                            root?.unmount();
                        } catch (e) {
                            // å¿½ç•¥æ¸…ç†é”™è¯¯ï¼Œå¯èƒ½å·²ç»è¢«æ¸…ç†
                            console.warn('Root unmount warning (safe to ignore):', e);
                        }
                    });
                }, 0);
            }
        };

        // å…ˆæ¸…ç†å¤±æ•ˆçš„æ ¹èŠ‚ç‚¹
        cleanupInvalidRoots();

        // è®°å½•å½“å‰å¤„ç†çš„å ä½ç¬¦ï¼Œç”¨äºé˜²æ­¢é‡å¤å¤„ç†
        const processedPlaceholders = new Set<Element>();

        // æŸ¥æ‰¾æ‰€æœ‰æŠ€èƒ½å ä½ç¬¦
        const skillPlaceholders = containerRef.current.querySelectorAll('.skill-placeholder[data-skill-name][data-skill-level]');

        skillPlaceholders.forEach((placeholder, index) => {
            // è·³è¿‡å·²å¤„ç†çš„å ä½ç¬¦
            if (processedPlaceholders.has(placeholder)) return;

            const skillName = placeholder.getAttribute('data-skill-name');
            const skillLevel = placeholder.getAttribute('data-skill-level');

            if (skillName && skillLevel) {
                // æ ‡è®°ä¸ºå·²å¤„ç†
                processedPlaceholders.add(placeholder);

                try {
                    // ç”Ÿæˆç¨³å®šçš„IDï¼Œå‚è€ƒå¤‡ä»½æ–‡ä»¶çš„é€»è¾‘ä½†ä¿æŒç¨³å®šæ€§
                    const contentHash = hashString(`${skillName}-${skillLevel}-${placeholder.textContent || ''}`);
                    const id = `skill-${skillName}-${skillLevel}-${contentHash}`;

                    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒIDçš„å®¹å™¨ï¼ˆå‚è€ƒMermaidé€»è¾‘ï¼‰
                    const existingContainer = document.getElementById(id);
                    if (existingContainer) {
                        // å¦‚æœå·²å­˜åœ¨ï¼Œç›´æ¥æ›¿æ¢å ä½ç¬¦ï¼ˆä¸Mermaidé€»è¾‘ä¿æŒä¸€è‡´ï¼‰
                        placeholder.parentNode?.replaceChild(existingContainer, placeholder);
                        logMermaid(`é‡ç”¨ç°æœ‰æŠ€èƒ½å®¹å™¨: ${skillName} (çº§åˆ«${skillLevel})`);
                        return;
                    }

                    // åˆ›å»ºä¸€ä¸ªæ–°çš„å®¹å™¨æ¥æ¸²æŸ“ SkillItem
                    const skillContainer = document.createElement('span');
                    skillContainer.style.display = 'inline';
                    skillContainer.id = id;

                    // æ·»åŠ æ•°æ®å±æ€§ï¼Œä¾¿äºè°ƒè¯•å’Œæ¢å¤
                    skillContainer.setAttribute('data-skill-name', skillName);
                    skillContainer.setAttribute('data-skill-level', skillLevel);
                    skillContainer.setAttribute('data-content-hash', contentHash);

                    // æ›¿æ¢å ä½ç¬¦
                    placeholder.parentNode?.replaceChild(skillContainer, placeholder);

                    // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰è¿™ä¸ªIDçš„æ ¹
                    if (rootsRef.current.has(id)) {
                        try {
                            // å°è¯•å¸è½½ç°æœ‰çš„æ ¹
                            rootsRef.current.get(id)?.unmount();
                            rootsRef.current.delete(id);
                        } catch (e) {
                            // å¿½ç•¥å¸è½½é”™è¯¯
                            console.warn('Root unmount warning (safe to ignore):', e);
                        }
                    }

                    // åˆ›å»ºæ ¹å¹¶å­˜å‚¨
                    const root = createRoot(skillContainer);
                    rootsRef.current.set(id, root);

                    // æ¸²æŸ“ SkillItem
                    const levelNumber = parseInt(skillLevel, 10) || 1;
                    root.render(
                        <SkillItem
                            skill={skillName}
                            level={levelNumber}
                        />
                    );

                    // æ·»åŠ å®¹å™¨å¯è§æ€§ç›‘å¬ï¼Œç¡®ä¿æŠ€èƒ½æ ‡ç­¾åœ¨å±•å¼€æ—¶é‡æ–°æ¸²æŸ“ï¼ˆå‚è€ƒMermaidé€»è¾‘ï¼‰
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach((entry) => {
                            if (entry.isIntersecting && entry.target === skillContainer) {
                                // å®¹å™¨å˜ä¸ºå¯è§æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°æ¸²æŸ“
                                setTimeout(() => {
                                    const skillElement = skillContainer.querySelector('[class*="skill"]');
                                    const needsRerender = !skillElement ||
                                                        skillContainer.innerHTML.length < 10 ||
                                                        skillContainer.getBoundingClientRect().width === 0;

                                    if (needsRerender) {
                                        logMermaid('ğŸ”„ SkillRendereræ£€æµ‹åˆ°éœ€è¦é‡æ–°æ¸²æŸ“æŠ€èƒ½æ ‡ç­¾', {
                                            skillName,
                                            level: levelNumber,
                                            containerId: id,
                                            innerHTML: skillContainer.innerHTML.substring(0, 100)
                                        });

                                        // é‡æ–°æ¸²æŸ“æŠ€èƒ½ç»„ä»¶
                                        try {
                                            const newRoot = createRoot(skillContainer);
                                            rootsRef.current.set(id, newRoot);
                                            newRoot.render(
                                                <SkillItem
                                                    skill={skillName}
                                                    level={levelNumber}
                                                />
                                            );
                                        } catch (rerenderError) {
                                            console.error('é‡æ–°æ¸²æŸ“æŠ€èƒ½æ ‡ç­¾å¤±è´¥:', rerenderError);
                                        }
                                    }
                                }, 100);
                            }
                        });
                    }, {
                        threshold: 0.1,
                        rootMargin: '50px'
                    });

                    observer.observe(skillContainer);

                    // å­˜å‚¨observerå¼•ç”¨ä»¥ä¾¿åç»­æ¸…ç†
                    skillContainer.setAttribute('data-observer-attached', 'true');

                    logMermaid(`æŠ€èƒ½ç»„ä»¶å·²åˆ›å»º: ${skillName} (çº§åˆ«${levelNumber})`);
                } catch (error) {
                    console.error('å¤„ç†æŠ€èƒ½å ä½ç¬¦å¤±è´¥:', error);
                    logMermaid(`æŠ€èƒ½ç»„ä»¶åˆ›å»ºå¤±è´¥: ${skillName} - ${error}`);
                }
            }
        });

        // æŸ¥æ‰¾æ‰€æœ‰Mermaidå ä½ç¬¦
        const mermaidPlaceholders = containerRef.current.querySelectorAll('.mermaid-placeholder[data-mermaid-chart][data-mermaid-id]');

        mermaidPlaceholders.forEach((placeholder, index) => {
            // è·³è¿‡å·²å¤„ç†çš„å ä½ç¬¦
            if (processedPlaceholders.has(placeholder)) return;

            const chart = placeholder.getAttribute('data-mermaid-chart');
            const chartId = placeholder.getAttribute('data-mermaid-id');

            if (chart && chartId) {
                // æ ‡è®°ä¸ºå·²å¤„ç†
                processedPlaceholders.add(placeholder);

                // ç”Ÿæˆç¨³å®šçš„IDï¼Œä½¿ç”¨å›¾è¡¨å†…å®¹å“ˆå¸Œè€Œä¸æ˜¯æ—¶é—´æˆ³
                const contentHash = hashString(`${chartId}-${chart}`);
                const id = `mermaid-${chartId}-${contentHash}`;

                // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒIDçš„å®¹å™¨
                const existingContainer = document.getElementById(id);
                if (existingContainer) {
                    // å¦‚æœå·²å­˜åœ¨ï¼Œç›´æ¥æ›¿æ¢å ä½ç¬¦
                    placeholder.parentNode?.replaceChild(existingContainer, placeholder);
                    return;
                }

                // åˆ›å»ºä¸€ä¸ªæ–°çš„å®¹å™¨æ¥æ¸²æŸ“ MermaidChart
                const mermaidContainer = document.createElement('div');
                mermaidContainer.style.display = 'block';
                mermaidContainer.id = id;

                // æ·»åŠ æ•°æ®å±æ€§ï¼Œä¾¿äºè°ƒè¯•å’Œæ¢å¤
                mermaidContainer.setAttribute('data-mermaid-id', chartId);
                mermaidContainer.setAttribute('data-content-hash', contentHash);

                // æ›¿æ¢å ä½ç¬¦
                placeholder.parentNode?.replaceChild(mermaidContainer, placeholder);

                // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰è¿™ä¸ªIDçš„æ ¹
                if (rootsRef.current.has(id)) {
                    try {
                        // å°è¯•å¸è½½ç°æœ‰çš„æ ¹
                        rootsRef.current.get(id)?.unmount();
                    } catch (e) {
                        // å¿½ç•¥å¸è½½é”™è¯¯
                        console.warn('Root unmount warning (safe to ignore):', e);
                    }
                }

                // åˆ›å»ºæ ¹å¹¶å­˜å‚¨
                const root = createRoot(mermaidContainer);
                rootsRef.current.set(id, root);

                // æ¸²æŸ“ MermaidLazyChart
                root.render(
                    <MermaidLazyChart
                        chart={chart}
                        id={chartId}
                        enableZoom={true}
                    />
                );

                // æ·»åŠ å®¹å™¨å¯è§æ€§ç›‘å¬ï¼Œç¡®ä¿å›¾è¡¨åœ¨å±•å¼€æ—¶é‡æ–°æ¸²æŸ“
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting && entry.target === mermaidContainer) {
                            // å®¹å™¨å˜ä¸ºå¯è§æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°æ¸²æŸ“
                            setTimeout(() => {
                                const svgElement = mermaidContainer.querySelector('svg');
                                const needsRerender = !svgElement ||
                                                    svgElement.innerHTML.length < 100 ||
                                                    !svgElement.innerHTML.includes('<g') ||
                                                    svgElement.getBoundingClientRect().width === 0;

                                if (needsRerender) {
                                    logMermaid('ğŸ”„ SkillRendereræ£€æµ‹åˆ°éœ€è¦é‡æ–°æ¸²æŸ“Mermaidå›¾è¡¨', {
                                        chartId,
                                        hasSvg: !!svgElement,
                                        contentLength: svgElement?.innerHTML.length || 0,
                                        hasGraphics: svgElement?.innerHTML.includes('<g') || false,
                                        width: svgElement?.getBoundingClientRect().width || 0,
                                        containerVisible: mermaidContainer.offsetParent !== null
                                    });

                                    // å¼‚æ­¥é‡æ–°æ¸²æŸ“ï¼Œé¿å…åœ¨æ¸²æŸ“å‘¨æœŸä¸­åŒæ­¥æ“ä½œ
                                    queueMicrotask(() => {
                                        try {
                                            // æ¸…ç†æ—§çš„æ ¹èŠ‚ç‚¹
                                            const oldRoot = rootsRef.current.get(id);
                                            if (oldRoot) {
                                                oldRoot.unmount();
                                                rootsRef.current.delete(id);
                                            }

                                            // æ¸…ç©ºå®¹å™¨å†…å®¹
                                            mermaidContainer.innerHTML = '';

                                            // åˆ›å»ºæ–°çš„æ ¹èŠ‚ç‚¹
                                            const newRoot = createRoot(mermaidContainer);
                                            rootsRef.current.set(id, newRoot);

                                            // å¼ºåˆ¶é‡æ–°æ¸²æŸ“
                                            const newId = `${chartId}-rerender-${Date.now()}`;
                                            logMermaid('ğŸ”„ å¼€å§‹é‡æ–°æ¸²æŸ“ï¼Œæ–°ID:', newId);

                                            newRoot.render(
                                                <MermaidLazyChart
                                                    chart={chart}
                                                    id={newId}
                                                    enableZoom={true}
                                                />
                                            );
                                        } catch (error) {
                                            console.warn('Mermaidé‡æ–°æ¸²æŸ“å¤±è´¥:', error);
                                        }
                                    });
                                }
                            }, 200);
                        }
                    });
                }, {
                    root: null,
                    rootMargin: '0px',
                    threshold: 0.1
                });

                observer.observe(mermaidContainer);

                // å­˜å‚¨observerä»¥ä¾¿æ¸…ç†
                (mermaidContainer as any)._observer = observer;

                // æš‚æ—¶ç¦ç”¨å®šæ—¶æ£€æŸ¥æœºåˆ¶ï¼Œé¿å…å¾ªç¯æ¸²æŸ“é—®é¢˜
                // TODO: å¦‚æœéœ€è¦å®šæ—¶æ£€æŸ¥ï¼Œå¯ä»¥è€ƒè™‘æ›´å®‰å…¨çš„å®ç°æ–¹å¼
                logMermaid('ï¿½ SkillRendererè·³è¿‡å®šæ—¶æ£€æŸ¥æœºåˆ¶ï¼Œé¿å…å¾ªç¯æ¸²æŸ“', { chartId });
            }
        });

        // æŸ¥æ‰¾æ‰€æœ‰Mermaidæ‡’åŠ è½½å ä½ç¬¦
        const mermaidLazyPlaceholders = containerRef.current.querySelectorAll('.mermaid-lazy-placeholder[data-mermaid-chart][data-mermaid-id]');

        mermaidLazyPlaceholders.forEach((placeholder, index) => {
            // è·³è¿‡å·²å¤„ç†çš„å ä½ç¬¦
            if (processedPlaceholders.has(placeholder)) return;

            const encodedChart = placeholder.getAttribute('data-mermaid-chart');
            const chartId = placeholder.getAttribute('data-mermaid-id');

            if (encodedChart && chartId) {
                try {
                    // æ ‡è®°ä¸ºå·²å¤„ç†
                    processedPlaceholders.add(placeholder);

                    // è§£ç å›¾è¡¨å†…å®¹
                    const chart = decodeURIComponent(encodedChart);

                    // ç”Ÿæˆç¨³å®šçš„IDï¼Œä½¿ç”¨å›¾è¡¨å†…å®¹å“ˆå¸Œè€Œä¸æ˜¯æ—¶é—´æˆ³
                    const contentHash = hashString(`lazy-${chartId}-${chart}`);
                    const id = `mermaid-lazy-${chartId}-${contentHash}`;

                    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒIDçš„å®¹å™¨
                    const existingContainer = document.getElementById(id);
                    if (existingContainer) {
                        // å¦‚æœå·²å­˜åœ¨ï¼Œç›´æ¥æ›¿æ¢å ä½ç¬¦
                        placeholder.parentNode?.replaceChild(existingContainer, placeholder);
                        return;
                    }

                    // åˆ›å»ºä¸€ä¸ªæ–°çš„å®¹å™¨æ¥æ¸²æŸ“ MermaidLazyChart
                    const mermaidLazyContainer = document.createElement('div');
                    mermaidLazyContainer.style.display = 'block';
                    mermaidLazyContainer.id = id;

                    // æ·»åŠ æ•°æ®å±æ€§ï¼Œä¾¿äºè°ƒè¯•å’Œæ¢å¤
                    mermaidLazyContainer.setAttribute('data-mermaid-id', chartId);
                    mermaidLazyContainer.setAttribute('data-content-hash', contentHash);
                    mermaidLazyContainer.setAttribute('data-lazy', 'true');

                    // æ›¿æ¢å ä½ç¬¦
                    placeholder.parentNode?.replaceChild(mermaidLazyContainer, placeholder);

                    // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰è¿™ä¸ªIDçš„æ ¹
                    if (rootsRef.current.has(id)) {
                        try {
                            // å°è¯•å¸è½½ç°æœ‰çš„æ ¹
                            rootsRef.current.get(id)?.unmount();
                        } catch (e) {
                            // å¿½ç•¥å¸è½½é”™è¯¯
                            console.warn('Root unmount warning (safe to ignore):', e);
                        }
                    }

                    // åˆ›å»ºæ ¹å¹¶å­˜å‚¨
                    const root = createRoot(mermaidLazyContainer);
                    rootsRef.current.set(id, root);

                    // æ¸²æŸ“ MermaidLazyChart
                    root.render(
                        <MermaidLazyChart
                            chart={chart}
                            id={chartId}
                            placeholderHeight="300px"
                        />
                    );

                    logMermaid('ğŸš€ SkillRendereråˆ›å»ºæ‡’åŠ è½½Mermaidå›¾è¡¨:', {
                        id,
                        chartId,
                        chartLength: chart.length
                    });

                } catch (error) {
                    console.error('âŒ SkillRendererå¤„ç†æ‡’åŠ è½½Mermaidå ä½ç¬¦å¤±è´¥:', error);
                }
            }
        });
    }, [children, isDark]); // å½“ children æˆ–ä¸»é¢˜å˜åŒ–æ—¶é‡æ–°æ¸²æŸ“

    // æ¸…ç†å‡½æ•°
    useEffect(() => {
        return () => {
            // æ¸…ç†æ‰€æœ‰observerå’Œå®šæ—¶å™¨
            if (containerRef.current) {
                const containers = containerRef.current.querySelectorAll('[id*="mermaid-chart"]');
                containers.forEach(container => {
                    const observer = (container as any)._observer;
                    if (observer) {
                        observer.disconnect();
                        delete (container as any)._observer;
                    }

                    const intervalCheck = (container as any)._intervalCheck;
                    if (intervalCheck) {
                        clearInterval(intervalCheck);
                        delete (container as any)._intervalCheck;
                    }
                });
            }

            // å¼‚æ­¥æ¸…ç†æ‰€æœ‰æ ¹èŠ‚ç‚¹ï¼Œé¿å…åœ¨æ¸²æŸ“å‘¨æœŸä¸­åŒæ­¥å¸è½½
            const rootsToCleanup = Array.from(rootsRef.current.values());
            rootsRef.current.clear();

            if (rootsToCleanup.length > 0) {
                setTimeout(() => {
                    rootsToCleanup.forEach(root => {
                        try {
                            root?.unmount();
                        } catch (e) {
                            // å¿½ç•¥æ¸…ç†é”™è¯¯ï¼Œç»„ä»¶å¯èƒ½å·²ç»è¢«æ¸…ç†
                            console.warn('Root cleanup warning (safe to ignore):', e);
                        }
                    });
                }, 0);
            }
        };
    }, []);

    return (
        <div ref={containerRef} style={{ display: 'contents' }}>
            {children}
        </div>
    );
};

export default SkillRenderer;
